---
title: "scRNAseq using Seurat and Harmony"
output: html_notebook
---


# Intro

This notebook demonstrates a basic scRNA-seq analysis pipeline using Seurat for single-cell RNA sequencing and Harmony for batch effect correction. The goal is to showcase essential steps, from data preprocessing to batch correction and visualization.

### Loading Required Libraries

We will use a built-in dataset to ensure accessibility for all users, allowing easy reproduction of the analysis.

```{r,results='hide',fig.keep='all'}
# Load necessary libraries for scRNA-seq analysis
library(harmony)        # Batch effect correction
library(Seurat)        # Core single-cell analysis toolkit
library(SeuratObject)  # Seurat object handling
library(SeuratData)    # Access to example datasets
library(SeuratWrappers) # Wrappers for additional functionalities
library(tidyverse)     # Data manipulation and visualization
library(ggplot2)       # Plotting
```
### Dataset Overview

For demonstration purposes, we will use a built-in dataset. This ensures that anyone can follow along without needing external datasets.

```{r,results='hide',fig.keep='all'}
# install data-set
install.packages("https://seurat.nygenome.org/src/contrib/ifnb.SeuratData_3.0.0.tar.gz", repos = NULL, type = "source")
InstallData("ifnb.SeuratData")
library(ifnb.SeuratData)

# load data-set
ifnb<-LoadData("ifnb")
```

### Preprocessing and Quality Control

Before performing batch correction and downstream analysis, we need to preprocess the data by normalizing, scaling, and identifying variable features. We also filter to exclude low quality cells.

```{r,results='hide',fig.keep='all'}
# QC and filtering
ifnb$mito.percent <- PercentageFeatureSet(ifnb, pattern = '-MT')

# filter
ifnb.filtered <- subset(ifnb, subset = nCount_RNA > 800 &
                          nFeature_RNA > 200 &
                          mito.percent < 5)
# Standard Workflow Steps
ifnb.filtered <- NormalizeData(ifnb.filtered)
ifnb.filtered <- FindVariableFeatures(ifnb.filtered)
ifnb.filtered <- ScaleData(ifnb.filtered)
```
### Dimensional Reduction with PCA

Principal Component Analysis (PCA) helps in reducing the dimensionality of the dataset while preserving key variations.

```{r,results='hide',fig.keep='all'}
ifnb.filtered <- RunPCA(ifnb.filtered)
ElbowPlot(ifnb.filtered)
ifnb.filtered <-  RunPCA(ifnb.filtered, dims = 1:20)

before <- DimPlot(ifnb.filtered, reduction = 'pca', group.by = 'stim')
```

### Batch Effect Correction with Harmony

If the dataset contains batch effects (e.g., multiple samples processed separately), we can use Harmony to correct them.

```{r,results='hide',fig.keep='all'}
# run Harmony
ifnb.harmony <- ifnb.filtered %>% 
  RunHarmony(group.by.vars = 'stim', plot_convergence = FALSE)

ifnb.harmony.embed <-Embeddings(ifnb.harmony, "harmony")
ifnb.harmony.embed[1:10,1:10]
```

### Clustering and Visualization

After batch correction, we proceed with clustering cells and visualizing the clusters.

```{r,results='hide',fig.keep='all'}
# clustering
ifnb.harmony <- ifnb.harmony %>%
  RunPCA(dims = 1:20) %>%
  FindNeighbors(reduction = 'harmony', dims = 1:20) %>%
  FindClusters(resolution = 0.5)
# visualize
after <- DimPlot(ifnb.harmony, reduction = 'harmony', group.by = 'stim')

before|after
```

### Visualization with UMAP/tSNE

Furthermore, after batch correction we can visualize our data using UMAP or tSNE embeddings to get a better of our cell types within the dataset.

```{r,results='hide',fig.keep='all'}
# UMAP
ifnb.harmony <- ifnb.harmony %>%
  RunUMAP(reduction = 'harmony', dims = 1:20) %>%
  FindNeighbors(reduction = 'harmony', dims = 1:20) %>%
  FindClusters(resolution = 0.5)
# visualize
after_umap <- DimPlot(ifnb.harmony, reduction='umap',group.by = c('stim','seurat_annotations'))
after_umap
```

